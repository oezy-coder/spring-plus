# Spring 플러스 개인 과제 README

## 프로젝트 개요
Spring Boot 기반 API 서버의 기능 개선 과제입니다. 레벨 1부터 레벨 3-10까지 단계별 요구사항에 따라
코드 리팩토링, N+1 문제 해결, QueryDSL 적용, Spring Security 도입 등을 수행하였습니다.

## 사용 기술
- Java 17
- Spring Boot 3.3.3
- Spring Web
- Spring Data JPA
- Spring Security
- QueryDSL
- JWT
- Lombok
- Gradle

## Level 1

### 1-1. 코드 개선 퀴즈 – @Transactional의 이해

#### 문제 상황
할 일을 저장하는 API(`/todos`)를 호출했을 때, 정상적으로 데이터가 저장되지 않고 에러가 발생했다.  
에러 메시지를 확인해 보니 `read-only` 트랜잭션에서 insert 쿼리가 실행되고 있었다.

#### 원인
- TodoService 클래스에 `@Transactional(readOnly = true)`가 클래스 레벨에 적용되어 있었고,  
이로 인해 할 일 저장 메서드에서도 읽기 전용 트랜잭션이 적용되고 있었다.  
- 그 결과 데이터 변경 쿼리가 실행되지 않았다.

#### 해결
- 할 일을 저장하는 메서드에는 `readOnly = true` 옵션이 적용되지 않도록 수정했다.  
- 저장 메서드에는 `@Transactional`을 별도로 적용하고,  
조회 메서드에만 `@Transactional(readOnly = true)`를 사용하도록 분리했다.

---

### 1-2. 코드 추가 퀴즈 – JWT의 이해

#### 문제 상황
기획 요구사항 변경으로 사용자 정보에 `nickname`이 필요해졌다.  
또한 프론트엔드에서 JWT 토큰을 통해 닉네임 값을 바로 꺼내 사용하고 싶어 했다.

#### 원인
- 기존 JWT 토큰에는 `userId`, `email`, `userRole`만 포함되어 있었고,  
`nickname` 값은 토큰에 포함되어 있지 않았다.  
- 이로 인해 인증 이후 사용자 정보에서 닉네임을 사용할 수 없었다.

#### 해결
- User 엔티티에 `nickname` 필드를 추가했다.
- WT 생성 시 `nickname`을 claim으로 추가했다.  
- 회원가입 및 로그인 과정에서도 닉네임 값을 함께 처리하도록 수정했다.  
- 이를 통해 인증 이후 컨트롤러에서 `AuthUser`를 통해 닉네임을 사용할 수 있도록 했다.

---

### 1-3. 코드 개선 퀴즈 – JPA의 이해

#### 문제 상황
할 일 목록 조회 API에서 검색 조건을 확장해야 했다.  
날씨(weather) 조건과 수정일 기준 기간 검색이 가능해야 했고,  
각 조건은 있을 수도 있고 없을 수도 있었다.

#### 원인
- 기존 조회 API는 페이징된 전체 조회만 가능했고,  
조건에 따라 검색하는 기능이 분리되어 있지 않았다.

#### 해결
- 컨트롤러에서 `weather`, `startDate`, `endDate`를 선택적으로 받을 수 있도록 수정했다.  
- 서비스 단에서는 조건 유무를 판단해 적절한 JPQL 쿼리를 호출하도록 분기 처리했다.  
- 날짜 검색은 `LocalDate`를 `LocalDateTime`으로 변환해 하루 범위로 조회되도록 처리했다.  
- 이를 통해 조건 조합에 따라 유연한 검색이 가능하도록 개선했다.

---

### 1-4. 테스트 코드 퀴즈 - 컨트롤러 테스트의 이해

#### 문제 상황
할 일 단건 조회 시 존재하지 않는 ID를 요청하면  
테스트는 실패하고 있었다.

#### 원인
- 실제 예외 처리에서는 `NOT_FOUND(404)`를 반환해야 했지만,  
테스트 코드에서는 `OK(200)` 기준으로 검증하고 있었다.

#### 해결
- `InvalidRequestException` 발생 시 `HttpStatus.NOT_FOUND`를 반환하도록 수정했다.  
- 컨트롤러 테스트에서도 상태 코드와 응답 값을 `NOT_FOUND` 기준으로 검증하도록 변경했다.  
- 이로써 테스트가 정상적으로 통과하도록 했다.

---

### 1-5. 코드 개선 퀴즈 - AOP의 이해

#### 문제 상황
관리자 권한 변경 API가 실행될 때 로그를 남기기 위해 AOP를 적용했지만,  
의도한 시점과 다른 타이밍에 로그가 찍히고 있었다.  
또한, 실제로 로그를 남겨야 하는 메서드가 아닌 다른 메서드에 AOP가 걸려 있었다.

#### 원인
- `@After` 어노테이션을 사용하여 메서드 실행 **이후**에 로그가 남도록 설정되어 있었다.
- 포인트컷이 `UserController.getUser()`로 지정되어 있어,  
  실제 요구사항인 관리자 권한 변경 메서드와 맞지 않았다.

#### 해결
- 관리자 권한이 변경되기 **이전**에 로그가 남도록 `@Before` 어노테이션으로 수정했다.
- 포인트컷을 `UserAdminController.changeUserRole()` 메서드로 변경하여  
  관리자 권한 변경 시점에만 AOP가 동작하도록 수정했다.
- 이를 통해 관리자 권한 변경 요청에 대해서만 정확한 로그가 남도록 개선했다.

---
## Level 2

### 2-6. JPA Cascade

#### 문제 상황
할 일을 새로 생성할 때, 해당 할 일을 만든 유저가 담당자로 자동 등록되지 않는 문제가 있었다.  
할 일 생성 시 `Manager` 엔티티를 함께 생성하고 있었지만, 별도로 저장하지 않아 담당자가 DB에 반영되지 않았다.

#### 원인
- `Todo`와 `Manager`가 1:N 관계로 매핑되어 있었지만,  
`Todo`를 저장할 때 연관된 `Manager` 엔티티가 함께 저장되도록 cascade 설정이 되어 있지 않았다.  
- 이로 인해 `Todo`는 저장되었지만 `Manager`는 영속화되지 않았다.

#### 해결
- `Todo` 엔티티의 `managers` 필드에 `cascade = CascadeType.PERSIST` 옵션을 추가했다.  
- 이를 통해 할 일을 저장할 때, 생성자에서 추가한 `Manager` 엔티티도 함께 저장되도록 수정했다.
- 그 결과, 할 일을 생성한 유저가 담당자로 자동 등록되도록 동작을 개선할 수 있었다.

---

### 2-7. N+1

#### 문제 상황
댓글 조회 API(`/todos/{todoId}/comments`)를 호출할 때, 하나의 요청에 비해 DB 쿼리가 과도하게 많이 실행되는 문제가 발생했다.

#### 원인
- 댓글 목록을 조회한 뒤, 각 댓글에 연관된 user를 지연 로딩(LAZY)으로 가져오면서  
댓글 개수만큼 user 조회 쿼리가 추가로 실행되는 N+1 문제가 발생했다.

#### 해결
- 댓글 조회 JPQL에 `JOIN FETCH c.user`를 적용해서 댓글과 유저 정보를 한 번의 쿼리로 함께 조회하도록 수정했다.  
- 이를 통해 불필요한 추가 쿼리가 발생하지 않도록 개선했다.

---

### 2-8. QueryDSL

#### 문제 상황
할 일 단건 조회 기능에서 JPQL로 작성된 `findByIdWithUser` 메서드를 사용하고 있었다.  
이 방식은 단순 조회에는 문제가 없지만, 조회 로직이 복잡해질 경우 유지보수가 어렵고  
확장성에도 한계가 있다고 느꼈다.  
또한 연관된 사용자 정보를 함께 조회할 때 N+1 문제가 발생하지 않도록 주의가 필요했다.

#### 해결
- JPQL로 작성된 조회 로직을 QueryDSL 기반으로 변경했다.  
- QueryDSL 설정을 위해 의존성을 추가하고 `JPAQueryFactory`를 Bean으로 등록했다.  
- 기존 `TodoRepository`에서 사용하던 단건 조회 메서드는 제거하고,  
`TodoCustomRepository`와 구현체를 분리해 QueryDSL 전용 조회 로직을 작성했다.

- QueryDSL에서 Todo와 User를 조인하여 한 번의 쿼리로 필요한 데이터를 조회하도록 수정했다.
  이 과정에서 연관 엔티티 조회로 인한 N+1 문제가 발생하지 않도록 개선했다.

#### 결과
- 단건 조회 로직을 QueryDSL로 변경하면서 쿼리 구조가 더 명확해졌고,  
필요한 데이터만 조회하도록 개선할 수 있었다.  
- 또한 연관 엔티티 조회 과정에서 N+1 문제가 발생하지 않도록 처리되어  
성능과 가독성 모두 개선되었다.

### 2-9. Spring Security 적용

#### 문제 상황
기존에는 Filter와 Argument Resolver를 직접 구현해서 인증과 권한 처리를 하고 있었다.  
JWT 검증, 사용자 정보 전달, 관리자 권한 체크까지 모두 직접 처리하다 보니  
보안 관련 로직이 한 곳에 모여 있고 코드도 점점 복잡해지고 있었다.

#### 원인
- Spring Security를 사용하지 않고 인증/인가 로직을 직접 구현하면서  
인증 흐름이 명확하지 않고, 역할 분리가 잘 되지 않은 상태였다.  
- 특히 Filter와 Controller에서 보안 관련 처리를 동시에 하고 있어 관리가 어려웠다.

#### 해결
기존 JWT 인증 방식은 유지하면서, 인증과 권한 관리를 Spring Security로 옮겼다.

- Spring Security 의존성을 추가하고 보안 설정 클래스를 작성했다.
- 기존 JwtFilter를 Spring Security 필터 체인에 포함되도록 수정했다.
- JWT 검증 후 Authentication 객체를 생성해 SecurityContext에 저장하도록 변경했다.
- 컨트롤러에서는 @AuthenticationPrincipal을 사용해 인증된 사용자 정보를 받도록 수정했다.
- 관리자 권한 체크는 Security 설정을 통해 처리하도록 정리했다.
- 이렇게 변경하면서 인증 흐름이 더 명확해졌고,  
보안 관련 로직도 Spring Security 구조 안에서 관리할 수 있게 되었다.

---

## Level 3

### 3-10. QueryDSL을 사용하여 검색 기능 만들기

QueryDSL을 사용하여 일정 검색 API를 구현하였다.  
검색 성능과 응답 데이터 최적화를 위해 Projections를 활용하여 필요한 필드만 조회하도록 구성하였다.

#### 구현 내용
- QueryDSL 기반의 검색 전용 API를 신규로 생성하였다.
- 제목, 담당자 닉네임, 생성일 범위를 조건으로 검색할 수 있도록 구현하였다.
    - 제목과 닉네임은 부분 일치 검색이 가능하도록 `contains` 조건을 사용하였다.
    - 생성일 범위는 시작일과 종료일을 기준으로 조회되도록 처리하였다.
- 검색 결과는 생성일 기준 최신순으로 정렬되도록 하였다.
- 검색 결과는 페이지네이션(offset, limit)을 적용하여 반환하도록 구현하였다.

#### 조회 데이터 최적화
- `Projections.constructor`를 사용하여 검색 결과 전용 DTO(`TodoSearchResponse`)로 조회하였다.
- 일정의 모든 정보를 조회하지 않고, 다음 정보만 반환하도록 제한하였다.
    - 일정 제목
    - 해당 일정의 댓글 개수
    - 해당 일정의 담당자 수

#### QueryDSL 조건 처리
- 검색 조건이 없는 경우를 고려하여 BooleanExpression을 분리하여 처리하였다.
- 각 조건 메서드는 값이 없을 경우 `null`을 반환하도록 하여 동적 쿼리가 적용되도록 구성하였다.
    - 제목 키워드 조건
    - 담당자 닉네임 조건
    - 생성일 시작/종료 조건

#### 연관 관계 처리
- 일정, 사용자, 댓글, 담당자 엔티티를 QueryDSL 조인을 통해 연결하였다.
- 필요한 데이터만 조회하는 구조이므로 엔티티 fetch join 대신 일반 join을 사용하였다.
- 댓글 수와 담당자 수는 `countDistinct`를 사용하여 중복 없이 집계되도록 처리하였다.

#### 서비스 계층 검증
- 검색 시작일이 종료일보다 늦은 경우 예외를 발생시키도록 검증 로직을 추가하였다.
- 날짜 검색은 LocalDate 기준으로 입력받아 LocalDateTime으로 변환하여 처리하였다.

---

## 느낀점
- 이번 과제를 통해 코드 리팩토링, N+1 문제 해결, Spring Security, QueryDSL 등을 직접 구현해볼 수 있었다.  
  특히 QueryDSL을 사용해 BooleanExpression으로 검색 조건을 조합하고,  
  LocalDate를 LocalDateTime으로 변환해 날짜 범위 검색을 처리하는 방식을 처음 적용해보았다.
- 이 방식이 검색 조건을 유연하게 처리하는 데 유용하다는 것을 알게 되었고,  
실제 구현을 통해 관련 개념들을 다시 정리할 수 있었다.  
다음에 비슷한 기능을 구현할 때는 이전보다 더 수월하게 접근할 수 있을 것 같다.
